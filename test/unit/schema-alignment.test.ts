/**
 * Schema-Type Alignment Verification
 *
 * Cross-validates three representations of the same data model:
 * 1. TypeScript types (client/types.ts) — interfaces with properties
 * 2. JSON Schemas (gateway/schemas/models/*.json) — for Fastify validation
 * 3. Catalog (client/catalog.json) — compiled intermediate with XSD metadata
 *
 * These are generated by different code paths. Drift between them causes
 * runtime failures (e.g., Fastify validation rejecting data that TS accepts).
 */
import { describe, it, expect, beforeAll } from "vitest";
import { mkdtempSync, readFileSync, readdirSync, rmSync } from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";
// noinspection ES6PreferShortImport
import { runGenerationPipeline } from "../../src/pipeline.js";

// ── Types for parsed representations ───────────────────────

interface TSProperty {
  name: string;
  type: string;
  optional: boolean;
  array: boolean;
}

interface TSInterface {
  name: string;
  properties: TSProperty[];
}

interface SchemaProperty {
  name: string;
  type: string | null; // null if $ref
  ref: string | null;
  required: boolean;
}

interface JSONSchemaInfo {
  $id: string;
  name: string; // derived from $id
  type: string; // "object" or "array"
  properties: SchemaProperty[];
}

interface CatalogElem {
  name: string;
  tsType: string;
  min: number;
  max: number | "unbounded";
  nillable: boolean;
  declaredType: string;
}

interface CatalogType {
  name: string;
  elems: CatalogElem[];
}

// ── Parsers ────────────────────────────────────────────────

/**
 * Parse TypeScript interfaces from generated types.ts source.
 * Works on the known structure of generated code (not arbitrary TS).
 *
 * Strategy: split by `export interface` boundaries (avoiding fragile nested-brace
 * regex), then extract property lines from each block.
 */
function parseTypeScript(source: string): Map<string, TSInterface> {
  const interfaces = new Map<string, TSInterface>();

  // Split into blocks starting at each `export interface`
  const blocks = source.split(/(?=^export interface )/m);

  for (const block of blocks) {
    const headerMatch = block.match(/^export interface (\w+)\s*\{/);
    if (!headerMatch) continue;

    const name = headerMatch[1];
    const properties: TSProperty[] = [];

    // Match property declarations: `  PropName?: Type[];`
    // This regex skips JSDoc lines (starting with * or /) and blank lines.
    const propRegex = /^\s+(\w+)(\?)?:\s+(.+);$/gm;
    let propMatch: RegExpExecArray | null;
    while ((propMatch = propRegex.exec(block)) !== null) {
      const propName = propMatch[1];
      const optional = propMatch[2] === "?";
      let rawType = propMatch[3].trim();
      const array = rawType.endsWith("[]");
      if (array) rawType = rawType.slice(0, -2);

      properties.push({ name: propName, type: rawType, optional, array });
    }

    interfaces.set(name, { name, properties });
  }

  return interfaces;
}

/**
 * Load all JSON Schema model files from a directory.
 */
function loadSchemas(dir: string): Map<string, JSONSchemaInfo> {
  const schemas = new Map<string, JSONSchemaInfo>();
  const files = readdirSync(dir).filter((f) => f.endsWith(".json"));

  for (const file of files) {
    const content = JSON.parse(readFileSync(join(dir, file), "utf-8"));
    const $id: string = content.$id || "";

    // Extract the type name from the URN: urn:services:weather:v1:schemas:models:typename
    const segments = $id.split(":");
    const rawName = segments[segments.length - 1];
    if (!rawName) continue;

    // Skip envelope/error schemas (they're gateway-specific, not data model)
    if (rawName.endsWith("_responseenvelope") || rawName === "weatherresponseenvelope" || rawName === "weathererrorobject") {
      continue;
    }

    const schemaType = content.type || "object";
    const properties: SchemaProperty[] = [];

    if (schemaType === "object" && content.properties) {
      const required = new Set<string>(content.required || []);
      for (const [propName, propSchema] of Object.entries<any>(content.properties)) {
        const type = propSchema.type || null;
        const ref = propSchema.$ref || null;
        properties.push({
          name: propName,
          type,
          ref,
          required: required.has(propName),
        });
      }
    }

    schemas.set(rawName.toLowerCase(), {
      $id,
      name: rawName,
      type: schemaType,
      properties,
    });
  }

  return schemas;
}

/**
 * Parse types from catalog.json.
 */
function parseCatalog(catalog: any): Map<string, CatalogType> {
  const types = new Map<string, CatalogType>();
  for (const t of catalog.types || []) {
    types.set(t.name, {
      name: t.name,
      elems: t.elems || [],
    });
  }
  return types;
}

// ── Mapping helpers ────────────────────────────────────────

/** Map TS primitive types to expected JSON Schema types */
function tsTypeToSchemaType(tsType: string): string | null {
  switch (tsType) {
    case "string": return "string";
    case "number": return "number";
    case "boolean": return "boolean";
    default: return null; // complex type → $ref
  }
}

// ── Test data ──────────────────────────────────────────────

const WSDL = join(import.meta.dirname, "..", "..", "examples", "minimal", "weather.wsdl");
let outDir: string;
let tsInterfaces: Map<string, TSInterface>;
let jsonSchemas: Map<string, JSONSchemaInfo>;
let catalogTypes: Map<string, CatalogType>;

// ── Setup ──────────────────────────────────────────────────

beforeAll(async () => {
  outDir = mkdtempSync(join(tmpdir(), "wsdl-align-"));
  await runGenerationPipeline({
    wsdl: WSDL,
    catalogOut: join(outDir, "client", "catalog.json"),
    clientOutDir: join(outDir, "client"),
    openapi: {
      outFile: join(outDir, "openapi.json"),
      format: "json",
    },
    gateway: {
      outDir: join(outDir, "gateway"),
      versionSlug: "v1",
      serviceSlug: "weather",
    },
  });

  const typesSource = readFileSync(join(outDir, "client", "types.ts"), "utf-8");
  tsInterfaces = parseTypeScript(typesSource);

  jsonSchemas = loadSchemas(join(outDir, "gateway", "schemas", "models"));

  const catalog = JSON.parse(readFileSync(join(outDir, "client", "catalog.json"), "utf-8"));
  catalogTypes = parseCatalog(catalog);

  return () => rmSync(outDir, { recursive: true, force: true });
}, 30_000);

// ── Existence tests ────────────────────────────────────────

describe("type existence alignment", () => {
  it("every catalog type has a matching TypeScript interface", () => {
    const missingInTS: string[] = [];
    for (const [name] of catalogTypes) {
      if (!tsInterfaces.has(name)) {
        missingInTS.push(name);
      }
    }
    expect(missingInTS).toEqual([]);
  });

  it("every catalog type has a matching JSON schema", () => {
    const missingInSchema: string[] = [];
    for (const [name] of catalogTypes) {
      const key = name.toLowerCase();
      if (!jsonSchemas.has(key)) {
        missingInSchema.push(name);
      }
    }
    expect(missingInSchema).toEqual([]);
  });

  it("every TypeScript interface has a matching catalog type", () => {
    const missingInCatalog: string[] = [];
    for (const [name] of tsInterfaces) {
      if (!catalogTypes.has(name)) {
        missingInCatalog.push(name);
      }
    }
    expect(missingInCatalog).toEqual([]);
  });
});

// ── Property count alignment ───────────────────────────────

describe("property count alignment", () => {
  it("TypeScript and catalog have same number of properties for each type", () => {
    const mismatches: string[] = [];
    for (const [name, catalogType] of catalogTypes) {
      const tsInterface = tsInterfaces.get(name);
      if (!tsInterface) continue;

      if (tsInterface.properties.length !== catalogType.elems.length) {
        mismatches.push(
          `${name}: TS has ${tsInterface.properties.length} props, catalog has ${catalogType.elems.length} elems`
        );
      }
    }
    expect(mismatches).toEqual([]);
  });

  it("TypeScript and JSON Schema have same properties for object types", () => {
    const mismatches: string[] = [];
    for (const [name, tsInterface] of tsInterfaces) {
      const key = name.toLowerCase();
      const schema = jsonSchemas.get(key);
      if (!schema || schema.type !== "object") continue;

      const tsNames = new Set(tsInterface.properties.map((p) => p.name));
      const schemaNames = new Set(schema.properties.map((p) => p.name));

      for (const n of tsNames) {
        if (!schemaNames.has(n)) {
          mismatches.push(`${name}.${n}: in TS but not in JSON Schema`);
        }
      }
      for (const n of schemaNames) {
        if (!tsNames.has(n)) {
          mismatches.push(`${name}.${n}: in JSON Schema but not in TS`);
        }
      }
    }
    expect(mismatches).toEqual([]);
  });
});

// ── Required/optional alignment ────────────────────────────

describe("required/optional alignment", () => {
  it("required properties in catalog (min >= 1) are non-optional in TypeScript", () => {
    const mismatches: string[] = [];
    for (const [name, catalogType] of catalogTypes) {
      const tsInterface = tsInterfaces.get(name);
      if (!tsInterface) continue;

      for (const elem of catalogType.elems) {
        if (elem.min >= 1) {
          const tsProp = tsInterface.properties.find((p) => p.name === elem.name);
          if (tsProp && tsProp.optional) {
            mismatches.push(`${name}.${elem.name}: required in catalog (min=${elem.min}) but optional in TS`);
          }
        }
      }
    }
    expect(mismatches).toEqual([]);
  });

  it("optional properties in catalog (min === 0) are optional in TypeScript", () => {
    const mismatches: string[] = [];
    for (const [name, catalogType] of catalogTypes) {
      const tsInterface = tsInterfaces.get(name);
      if (!tsInterface) continue;

      for (const elem of catalogType.elems) {
        if (elem.min === 0) {
          const tsProp = tsInterface.properties.find((p) => p.name === elem.name);
          if (tsProp && !tsProp.optional) {
            mismatches.push(`${name}.${elem.name}: optional in catalog (min=0) but required in TS`);
          }
        }
      }
    }
    expect(mismatches).toEqual([]);
  });

  it("required properties in catalog are required in JSON Schema", () => {
    const mismatches: string[] = [];
    for (const [name, catalogType] of catalogTypes) {
      const key = name.toLowerCase();
      const schema = jsonSchemas.get(key);
      if (!schema || schema.type !== "object") continue;

      for (const elem of catalogType.elems) {
        if (elem.min >= 1) {
          const schemaProp = schema.properties.find((p) => p.name === elem.name);
          if (schemaProp && !schemaProp.required) {
            mismatches.push(`${name}.${elem.name}: required in catalog but not required in JSON Schema`);
          }
        }
      }
    }
    expect(mismatches).toEqual([]);
  });

  it("optional properties in catalog are not required in JSON Schema", () => {
    const mismatches: string[] = [];
    for (const [name, catalogType] of catalogTypes) {
      const key = name.toLowerCase();
      const schema = jsonSchemas.get(key);
      if (!schema || schema.type !== "object") continue;

      for (const elem of catalogType.elems) {
        if (elem.min === 0) {
          const schemaProp = schema.properties.find((p) => p.name === elem.name);
          if (schemaProp && schemaProp.required) {
            mismatches.push(`${name}.${elem.name}: optional in catalog but required in JSON Schema`);
          }
        }
      }
    }
    expect(mismatches).toEqual([]);
  });
});

// ── Type mapping alignment ─────────────────────────────────

describe("type mapping alignment", () => {
  it("primitive TS types map to correct JSON Schema types", () => {
    const mismatches: string[] = [];
    for (const [name, tsInterface] of tsInterfaces) {
      const key = name.toLowerCase();
      const schema = jsonSchemas.get(key);
      if (!schema || schema.type !== "object") continue;

      for (const tsProp of tsInterface.properties) {
        const expectedSchemaType = tsTypeToSchemaType(tsProp.type);
        if (!expectedSchemaType) continue; // complex type, skip

        const schemaProp = schema.properties.find((p) => p.name === tsProp.name);
        if (!schemaProp) continue;

        if (schemaProp.type !== expectedSchemaType) {
          mismatches.push(
            `${name}.${tsProp.name}: TS type '${tsProp.type}' → expected schema '${expectedSchemaType}', got '${schemaProp.type}'`
          );
        }
      }
    }
    expect(mismatches).toEqual([]);
  });

  it("complex TS types map to $ref in JSON Schema", () => {
    const mismatches: string[] = [];
    for (const [name, tsInterface] of tsInterfaces) {
      const key = name.toLowerCase();
      const schema = jsonSchemas.get(key);
      if (!schema || schema.type !== "object") continue;

      for (const tsProp of tsInterface.properties) {
        // Skip primitives
        if (tsTypeToSchemaType(tsProp.type)) continue;

        const schemaProp = schema.properties.find((p) => p.name === tsProp.name);
        if (!schemaProp) continue;

        if (!schemaProp.ref) {
          mismatches.push(
            `${name}.${tsProp.name}: TS type '${tsProp.type}' (complex) but no $ref in JSON Schema`
          );
        }
      }
    }
    expect(mismatches).toEqual([]);
  });

  it("catalog tsType matches TypeScript property type", () => {
    const mismatches: string[] = [];
    for (const [name, catalogType] of catalogTypes) {
      const tsInterface = tsInterfaces.get(name);
      if (!tsInterface) continue;

      for (const elem of catalogType.elems) {
        const tsProp = tsInterface.properties.find((p) => p.name === elem.name);
        if (!tsProp) continue;

        // For array types, the catalog elem has max=unbounded and tsType is the element type
        if (elem.max === "unbounded") {
          if (!tsProp.array) {
            mismatches.push(`${name}.${elem.name}: catalog says unbounded but TS is not an array`);
          } else if (tsProp.type !== elem.tsType) {
            mismatches.push(`${name}.${elem.name}: catalog tsType='${elem.tsType}' but TS array element='${tsProp.type}'`);
          }
        } else {
          if (tsProp.type !== elem.tsType) {
            mismatches.push(`${name}.${elem.name}: catalog tsType='${elem.tsType}' but TS type='${tsProp.type}'`);
          }
        }
      }
    }
    expect(mismatches).toEqual([]);
  });
});

// ── ArrayOf* alignment (known issue detection) ─────────────

describe("ArrayOf* type alignment", () => {
  it("identifies ArrayOf* types in all three representations", () => {
    // Catalog represents ArrayOf* as object types with one unbounded element
    const arrayOfTypes: string[] = [];
    for (const [name, catalogType] of catalogTypes) {
      if (name.startsWith("ArrayOf") && catalogType.elems.length === 1 && catalogType.elems[0].max === "unbounded") {
        arrayOfTypes.push(name);
      }
    }
    expect(arrayOfTypes.length).toBeGreaterThan(0);

    // TypeScript represents them as interfaces with one array property
    for (const name of arrayOfTypes) {
      const tsInterface = tsInterfaces.get(name);
      expect(tsInterface, `TS interface for ${name}`).toBeDefined();
      expect(tsInterface!.properties.length).toBe(1);
      expect(tsInterface!.properties[0].array).toBe(true);
    }
  });

  it("documents ArrayOf* schema-type structure difference (resolved by runtime unwrap)", () => {
    // JSON Schemas flatten ArrayOf* to type: "array" while TypeScript preserves
    // the wrapper object structure. The generated unwrapArrayWrappers() function
    // bridges this gap at runtime by stripping wrapper objects before serialization.
    const arrayOfTypes: string[] = [];
    for (const [name] of catalogTypes) {
      if (name.startsWith("ArrayOf")) {
        arrayOfTypes.push(name);
      }
    }

    for (const name of arrayOfTypes) {
      const key = name.toLowerCase();
      const schema = jsonSchemas.get(key);
      expect(schema, `Schema exists for ${name}`).toBeDefined();

      const tsInterface = tsInterfaces.get(name);
      expect(tsInterface, `TS interface exists for ${name}`).toBeDefined();

      // JSON Schema uses type: "array" (flattened)
      expect(schema!.type).toBe("array");
      // TypeScript uses { ElementName?: ElementType[] } (wrapper object)
      expect(tsInterface!.properties.length).toBe(1);
      expect(tsInterface!.properties[0].array).toBe(true);
      // The mismatch is resolved by unwrapArrayWrappers() in the generated runtime.ts
    }
  });
});

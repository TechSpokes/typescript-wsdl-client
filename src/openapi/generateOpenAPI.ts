/**
 * OpenAPI 3.1 Generator from WSDL
 *
 * This module generates OpenAPI 3.1 specifications from WSDL documents or compiled catalogs.
 * It bridges the gap between SOAP web services and REST APIs by creating an OpenAPI
 * representation that mirrors the TypeScript model generated by the WSDL client generator.
 *
 * The generator supports:
 * - Multiple input sources (WSDL URL/path, pre-compiled catalog, or in-memory catalog)
 * - Customizable paths, operations, and schemas
 * - Security scheme configuration
 * - Custom operation tagging and metadata
 * - Multiple output formats (JSON, YAML, or both)
 * - OpenAPI validation
 */
import * as fs from "fs";
import * as path from "path";
import * as yaml from "js-yaml";
import {loadWsdl} from "../loader/wsdlLoader.js";
import {compileCatalog, type CompiledCatalog} from "../compiler/schemaCompiler.js";
import {buildSchemas} from "./buildSchemas.js";
import {buildPaths} from "./buildPaths.js";
import {buildSecurity, loadSecurityConfig} from "./security.js";
import type {PathStyle} from "./casing.js";

/**
 * Options for OpenAPI generation from WSDL
 *
 * @interface GenerateOpenAPIOptions
 * @property {string} [wsdl] - Path or URL to WSDL file (exclusive with catalogFile and compiledCatalog)
 * @property {string} [catalogFile] - Path to existing compiled catalog.json (exclusive with wsdl and compiledCatalog)
 * @property {CompiledCatalog} [compiledCatalog] - Pre-compiled catalog in memory (exclusive with wsdl and catalogFile)
 * @property {string} [outFile] - Output path for generated OpenAPI specification
 * @property {string} [title] - API title (defaults to derived service name)
 * @property {string} [version] - API version for info.version (default 0.0.0)
 * @property {string} [description] - API description
 * @property {string[]} [servers] - List of server URLs
 * @property {string} [basePath] - Base path prefix (e.g., /v1/soap)
 * @property {PathStyle} [pathStyle] - Path segment style: kebab, asis, or lower
 * @property {string} [defaultMethod] - Default HTTP method: post, get, put, patch, delete
 * @property {string} [securityConfigFile] - Path to security.json configuration
 * @property {string} [tagsFile] - Path to tags.json mapping operation names to tags
 * @property {string} [opsFile] - Path to ops.json with per-operation overrides
 * @property {boolean} [closedSchemas] - Whether to emit additionalProperties:false
 * @property {boolean} [pruneUnusedSchemas] - Whether to exclude schemas not referenced by operations
 * @property {boolean} [asYaml] - Force YAML output regardless of extension (deprecated)
 * @property {boolean} [validate] - Whether to validate using swagger-parser
 * @property {"default"|"first"|"service"} [tagStyle] - Heuristic for deriving tags
 * @property {"json"|"yaml"|"both"} [format] - Output format (default: json)
 * @property {boolean} [skipValidate] - Skip validation (default: false)
 */
export interface GenerateOpenAPIOptions {
  wsdl?: string;                 // path or URL (exclusive with catalog)
  catalogFile?: string;          // existing compiled catalog.json
  outFile?: string;              // where to write resulting OpenAPI JSON
  title?: string;
  version?: string;
  description?: string;
  servers?: string[];            // server URLs
  basePath?: string;             // base path prefix (e.g. /v1/soap)
  pathStyle?: PathStyle;         // kebab|asis|lower
  defaultMethod?: string;        // post|get|put|patch - default method
  securityConfigFile?: string;   // security.json path
  tagsFile?: string;             // tags.json path mapping op->tag
  opsFile?: string;              // ops.json path overrides
  closedSchemas?: boolean;
  pruneUnusedSchemas?: boolean;
  asYaml?: boolean;            // force YAML output regardless of extension
  validate?: boolean;          // validate using swagger-parser
  tagStyle?: "default" | "first" | "service"; // heuristics when no explicit tag map
  compiledCatalog?: CompiledCatalog; // optional precompiled catalog to skip reloading
  format?: "json" | "yaml" | "both"; // new unified format selector (default json)
  skipValidate?: boolean;               // opt-out of validation (always validates otherwise)
}

export async function generateOpenAPI(opts: GenerateOpenAPIOptions): Promise<{
  doc: any;
  jsonPath?: string;
  yamlPath?: string;
}> {
  // Normalize format (back-compat: asYaml overrides if provided and format not set)
  let format: "json" | "yaml" | "both" = opts.format || (opts.asYaml ? "yaml" : "json");
  if (format === "yaml" && opts.asYaml && opts.outFile && /\.json$/i.test(opts.outFile)) {
    // user asked for yaml but provided .json path → we'll still switch extension
  }

  if (!opts.compiledCatalog && !opts.wsdl && !opts.catalogFile) {
    throw new Error("Provide one of: compiledCatalog, wsdl, or catalogFile");
  }
  if ((opts.wsdl && opts.catalogFile) || (opts.compiledCatalog && (opts.wsdl || opts.catalogFile))) {
    // Not strictly an error, but disallow ambiguous multi-source inputs to keep deterministic
    // Users should supply only ONE source of truth.
    throw new Error("Provide only one source: compiledCatalog OR wsdl OR catalogFile");
  }

  let compiled: CompiledCatalog;
  if (opts.compiledCatalog) {
    compiled = opts.compiledCatalog;
  } else if (opts.catalogFile) {
    const raw = fs.readFileSync(opts.catalogFile, "utf8");
    compiled = JSON.parse(raw);
  } else {
    const wsdlCatalog = await loadWsdl(String(opts.wsdl));
    compiled = compileCatalog(wsdlCatalog, {
      // minimal compiler options (no generation side effects needed here)
      wsdl: String(opts.wsdl),
      out: "",
      imports: "js",
      catalog: false,
      primitive: {int64As: "string", bigIntegerAs: "string", decimalAs: "string", dateAs: "string"},
      choice: "all-optional",
      failOnUnresolved: false,
      attributesKey: "$attributes",
      nillableAsOptional: false,
      clientName: undefined,
    });
  }

  const title = opts.title || (compiled.serviceName ? `${compiled.serviceName} SOAP API` : "Generated SOAP API");
  const infoVersion = opts.version || "0.0.0";

  // Load external config files (optional)
  const tagsMap = opts.tagsFile ? safeJson(opts.tagsFile) : undefined;
  const opsOverrides = opts.opsFile ? safeJson(opts.opsFile) : undefined;
  const securityCfg = loadSecurityConfig(opts.securityConfigFile);
  const securityBuilt = buildSecurity(securityCfg);

  // Build components.schemas
  const schemas = buildSchemas(compiled, {
    closedSchemas: opts.closedSchemas,
    pruneUnusedSchemas: opts.pruneUnusedSchemas
  });

  // Build paths
  const tagStyle = opts.tagStyle || "default";
  const defaultTag = (() => {
    if (tagStyle === "service") return compiled.serviceName || "SOAP";
    if (tagStyle === "first") return "General"; // fallback; per-op derivation below
    return compiled.serviceName || "SOAP";
  })();
  const paths = buildPaths(compiled, {
    basePath: opts.basePath || "/",
    pathStyle: opts.pathStyle || "kebab",
    defaultMethod: opts.defaultMethod || "post",
    tagsMap,
    overrides: opsOverrides,
    defaultTag,
    opSecurity: securityBuilt.opSecurity,
    opHeaderParameters: securityBuilt.opHeaderParameters,
  });

  // Apply tag heuristics for operations missing explicit tag if style=first
  if (tagStyle === "first") {
    for (const p of Object.values(paths)) {
      for (const methodObj of Object.values(p as any)) {
        if (Array.isArray((methodObj as any).tags) && (methodObj as any).tags[0] === "General") {
          const opId = (methodObj as any).operationId || "Op";
          const seg = opId.replace(/([a-z0-9])([A-Z])/g, "$1 $2").split(/[^A-Za-z0-9]+/).filter(Boolean)[0] || "General";
          (methodObj as any).tags = [seg];
        }
      }
    }
  }

  const doc: any = {
    openapi: "3.1.0",
    jsonSchemaDialect: "https://json-schema.org/draft/2020-12/schema",
    info: {title, version: infoVersion},
    paths,
    components: {
      schemas,
      ...(securityBuilt.securitySchemes ? {securitySchemes: securityBuilt.securitySchemes} : {}),
      ...(Object.keys(securityBuilt.headerParameters).length ? {parameters: securityBuilt.headerParameters} : {}),
    },
  };
  if (opts.description) doc.info.description = opts.description;
  if (opts.servers && opts.servers.length) {
    doc.servers = opts.servers.map(u => ({url: u}));
  }

  if (opts.skipValidate !== true) {
    try {
      const parser = await import("@apidevtools/swagger-parser");
      await parser.default.validate(JSON.parse(JSON.stringify(doc)));
      console.log("OpenAPI validation: OK");
    } catch (e) {
      console.error("OpenAPI validation failed:", e instanceof Error ? e.message : e);
      throw e;
    }
  } else {
    console.log("OpenAPI validation skipped by flag");
  }

  // Determine base path for writing
  let base: string | undefined = opts.outFile;
  if (base) {
    const extMatch = base.match(/\.(json|ya?ml)$/i);
    if (extMatch) {
      base = base.slice(0, -extMatch[0].length); // strip extension
    }
  }
  let jsonPath: string | undefined;
  let yamlPath: string | undefined;

  if (opts.outFile) {
    const dir = path.dirname(opts.outFile);
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, {recursive: true});

    if (format === "json") {
      jsonPath = base ? `${base}.json` : opts.outFile;
      fs.writeFileSync(jsonPath, JSON.stringify(doc, null, 2), "utf8");
    } else if (format === "yaml") {
      yamlPath = base ? `${base}.yaml` : opts.outFile.replace(/\.(json)$/i, ".yaml");
      fs.writeFileSync(yamlPath, yaml.dump(doc), "utf8");
    } else { // both
      jsonPath = `${base}.json`;
      yamlPath = `${base}.yaml`;
      fs.writeFileSync(jsonPath, JSON.stringify(doc, null, 2), "utf8");
      fs.writeFileSync(yamlPath, yaml.dump(doc), "utf8");
    }
  }

  return {doc, jsonPath, yamlPath};
}

function safeJson(file: string): any | undefined {
  try {
    return JSON.parse(fs.readFileSync(file, "utf8"));
  } catch (e) {
    console.warn(`⚠️ Failed to parse JSON file '${file}': ${e instanceof Error ? e.message : String(e)}`);
    return undefined;
  }
}

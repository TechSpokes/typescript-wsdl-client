// noinspection DuplicatedCode

/**
 * Test File Emitters
 *
 * Functions that produce test file content as template strings.
 * Follows the same pattern as src/gateway/generators.ts.
 *
 * All emitters receive importsMode and compute relative import paths
 * via computeRelativeImport() from src/util/imports.ts.
 */
import {computeRelativeImport} from "../util/imports.js";
import type {ClientMeta, ResolvedOperationMeta} from "../gateway/helpers.js";
import type {CatalogForMocks} from "./mockData.js";
import {detectArrayWrappers, detectChildrenTypes} from "../util/catalogMeta.js";

/** Pre-computed mock data map passed from the orchestrator to all emitters. */
export type OperationMocksMap = Map<string, { request: Record<string, unknown>; response: Record<string, unknown> }>;

/**
 * Emits vitest.config.ts content.
 *
 * Sets root to __dirname so test glob patterns resolve relative to the
 * config file location, not the working directory.
 */
export function emitVitestConfig(): string {
  return `import { defineProject } from "vitest/config";
import { dirname } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));

export default defineProject({
  test: {
    root: __dirname,
    include: [
      "gateway/**/*.test.ts",
      "runtime/**/*.test.ts",
    ],
    testTimeout: 30000,
  },
});
`;
}

/**
 * Emits helpers/mock-client.ts content with full default responses per operation.
 *
 * @param testDir - Absolute path to test output directory
 * @param clientDir - Absolute path to client directory
 * @param importsMode - Import extension mode
 * @param clientMeta - Client metadata
 * @param operations - Resolved operation metadata
 * @param mocks - Pre-computed mock data map
 */
export function emitMockClientHelper(
  testDir: string,
  clientDir: string,
  importsMode: "js" | "ts" | "bare",
  clientMeta: ClientMeta,
  operations: ResolvedOperationMeta[],
  mocks: OperationMocksMap
): string {
  const helpersDir = `${testDir}/helpers`;
  const operationsImport = computeRelativeImport(helpersDir, `${clientDir}/operations`, importsMode);

  // Sort operations for deterministic output
  const sortedOps = [...operations].sort((a, b) => a.operationId.localeCompare(b.operationId));

  const methodEntries = sortedOps.map((op) => {
    const mockData = mocks.get(op.operationId);
    const response = mockData?.response ?? {};
    const responseJson = JSON.stringify(response, null, 6).replace(/\n/g, "\n    ");

    return `    ${op.operationId}: async () => ({
      response: ${responseJson},
      headers: {},
    })`;
  }).join(",\n");

  return `/**
 * Mock SOAP Client Helper
 *
 * Creates a mock client implementing the ${clientMeta.className}Operations interface
 * with full default responses per operation. Override individual methods as needed.
 *
 * Auto-generated by wsdl-tsc --test-dir. Customize freely.
 */
import type { ${clientMeta.className}Operations } from "${operationsImport}";

/**
 * Creates a mock SOAP client with default responses for all operations.
 *
 * Response shapes match the real SOAP client wrapper structure.
 * ArrayOf* types use wrapper objects (e.g. { Forecast: [...] }).
 * The generated unwrapArrayWrappers() function strips these at runtime.
 *
 * @param overrides - Override specific operation implementations
 * @returns Mock client implementing ${clientMeta.className}Operations
 */
export function createMockClient(
  overrides: Partial<${clientMeta.className}Operations> = {}
): ${clientMeta.className}Operations {
  return {
${methodEntries},
    ...overrides,
  } as ${clientMeta.className}Operations;
}
`;
}

/**
 * Emits helpers/test-app.ts content.
 *
 * @param testDir - Absolute path to test output directory
 * @param gatewayDir - Absolute path to gateway directory
 * @param importsMode - Import extension mode
 * @param clientMeta - Client metadata
 */
export function emitTestAppHelper(
  testDir: string,
  gatewayDir: string,
  importsMode: "js" | "ts" | "bare",
  clientMeta: ClientMeta
): string {
  const helpersDir = `${testDir}/helpers`;
  const suffix = importsMode === "bare" ? "" : `.${importsMode}`;
  const pluginImport = computeRelativeImport(helpersDir, `${gatewayDir}/plugin`, importsMode);
  const mockClientImport = `./mock-client${suffix}`;

  return `/**
 * Test App Helper
 *
 * Creates a Fastify instance with the generated gateway plugin and a mock client.
 * Uses static imports for reliable module resolution.
 *
 * Auto-generated by wsdl-tsc --test-dir. Customize freely.
 */
import Fastify, { type FastifyInstance } from "fastify";
import gatewayPlugin from "${pluginImport}";
import type { ${clientMeta.className}Operations } from "${computeRelativeImport(helpersDir, `${gatewayDir}/../client/operations`, importsMode)}";
import { createMockClient } from "${mockClientImport}";

export { createMockClient };

/**
 * Creates a Fastify app with the gateway plugin and a mock (or custom) client.
 *
 * @param client - Optional client override (defaults to createMockClient())
 * @returns Ready Fastify instance
 */
export async function createTestApp(
  client?: ${clientMeta.className}Operations
): Promise<FastifyInstance> {
  const app = Fastify({ logger: false });
  await app.register(gatewayPlugin, {
    client: client ?? createMockClient(),
  });
  await app.ready();
  return app;
}
`;
}

/**
 * Emits gateway/routes.test.ts with one test per operation.
 *
 * @param testDir - Absolute path to test output directory
 * @param importsMode - Import extension mode
 * @param operations - Resolved operation metadata
 * @param mocks - Pre-computed mock data map
 */
// noinspection JSUnusedLocalSymbols
export function emitRoutesTest(
  testDir: string,
  importsMode: "js" | "ts" | "bare",
  operations: ResolvedOperationMeta[],
  mocks: OperationMocksMap
): string {
  const suffix = importsMode === "bare" ? "" : `.${importsMode}`;
  const testAppImport = `../helpers/test-app${suffix}`;

  // Sort operations for deterministic output
  const sortedOps = [...operations].sort((a, b) => a.operationId.localeCompare(b.operationId));

  const testCases = sortedOps.map((op) => {
    const mockData = mocks.get(op.operationId);
    const requestPayload = JSON.stringify(mockData?.request ?? {}, null, 4).replace(/\n/g, "\n    ");

    return `  it("${op.method.toUpperCase()} ${op.path} returns SUCCESS envelope", async () => {
    const app = await createTestApp();
    try {
      const res = await app.inject({
        method: "${op.method.toUpperCase()}",
        url: "${op.path}",
        payload: ${requestPayload},
      });
      expect(res.statusCode).toBe(200);
      const body = res.json();
      expect(body.status).toBe("SUCCESS");
      expect(body.data).toBeDefined();
      expect(body.error).toBeNull();
    } finally {
      await app.close();
    }
  });`;
  }).join("\n\n");

  return `/**
 * Gateway Routes — Happy Path Tests
 *
 * One test per operation: inject request, assert 200 + SUCCESS envelope.
 *
 * Auto-generated by wsdl-tsc --test-dir. Customize freely.
 */
import { describe, it, expect } from "vitest";
import { createTestApp } from "${testAppImport}";

describe("gateway routes — happy path", () => {
${testCases}
});
`;
}

/**
 * Emits gateway/errors.test.ts with error classification tests through Fastify.
 *
 * @param testDir - Absolute path to test output directory
 * @param importsMode - Import extension mode
 * @param operations - Resolved operation metadata (uses first operation for error tests)
 * @param mocks - Pre-computed mock data map
 */
// noinspection JSUnusedLocalSymbols
export function emitErrorsTest(
  testDir: string,
  importsMode: "js" | "ts" | "bare",
  operations: ResolvedOperationMeta[],
  mocks: OperationMocksMap
): string {
  const suffix = importsMode === "bare" ? "" : `.${importsMode}`;
  const testAppImport = `../helpers/test-app${suffix}`;
  const mockClientImport = `../helpers/mock-client${suffix}`;

  // Use first operation for error tests
  const sortedOps = [...operations].sort((a, b) => a.operationId.localeCompare(b.operationId));
  const op = sortedOps[0];
  if (!op) return "// No operations found\n";

  const mockData = mocks.get(op.operationId);
  const requestPayload = JSON.stringify(mockData?.request ?? {}, null, 4).replace(/\n/g, "\n    ");

  return `/**
 * Gateway Error Handling Tests
 *
 * Tests error classification through Fastify: 500, 502, 503, 504.
 *
 * Auto-generated by wsdl-tsc --test-dir. Customize freely.
 */
import { describe, it, expect } from "vitest";
import { createTestApp } from "${testAppImport}";
import { createMockClient } from "${mockClientImport}";

describe("gateway routes — error handling", () => {
  it("returns 500 for generic errors", async () => {
    const app = await createTestApp(
      createMockClient({
        ${op.operationId}: async () => {
          throw new Error("something broke");
        },
      })
    );
    try {
      const res = await app.inject({
        method: "${op.method.toUpperCase()}",
        url: "${op.path}",
        payload: ${requestPayload},
      });
      expect(res.statusCode).toBe(500);
      const body = res.json();
      expect(body.status).toBe("ERROR");
      expect(body.error.code).toBe("INTERNAL_ERROR");
    } finally {
      await app.close();
    }
  });

  it("returns 502 for SOAP fault errors", async () => {
    const app = await createTestApp(
      createMockClient({
        ${op.operationId}: async () => {
          throw Object.assign(new Error("SOAP fault"), {
            root: {
              Envelope: {
                Body: {
                  Fault: {
                    faultcode: "soap:Server",
                    faultstring: "Service error",
                  },
                },
              },
            },
          });
        },
      })
    );
    try {
      const res = await app.inject({
        method: "${op.method.toUpperCase()}",
        url: "${op.path}",
        payload: ${requestPayload},
      });
      expect(res.statusCode).toBe(502);
      const body = res.json();
      expect(body.status).toBe("ERROR");
      expect(body.error.code).toBe("SOAP_FAULT");
    } finally {
      await app.close();
    }
  });

  it("returns 503 for connection errors", async () => {
    const app = await createTestApp(
      createMockClient({
        ${op.operationId}: async () => {
          throw new Error("connect ECONNREFUSED 127.0.0.1:80");
        },
      })
    );
    try {
      const res = await app.inject({
        method: "${op.method.toUpperCase()}",
        url: "${op.path}",
        payload: ${requestPayload},
      });
      expect(res.statusCode).toBe(503);
      const body = res.json();
      expect(body.status).toBe("ERROR");
      expect(body.error.code).toBe("SERVICE_UNAVAILABLE");
    } finally {
      await app.close();
    }
  });

  it("returns 504 for timeout errors", async () => {
    const app = await createTestApp(
      createMockClient({
        ${op.operationId}: async () => {
          throw new Error("ETIMEDOUT");
        },
      })
    );
    try {
      const res = await app.inject({
        method: "${op.method.toUpperCase()}",
        url: "${op.path}",
        payload: ${requestPayload},
      });
      expect(res.statusCode).toBe(504);
      const body = res.json();
      expect(body.status).toBe("ERROR");
      expect(body.error.code).toBe("GATEWAY_TIMEOUT");
    } finally {
      await app.close();
    }
  });
});
`;
}

/**
 * Emits gateway/envelope.test.ts with SUCCESS/ERROR structure assertions.
 */
// noinspection JSUnusedLocalSymbols
export function emitEnvelopeTest(
  testDir: string,
  importsMode: "js" | "ts" | "bare",
  operations: ResolvedOperationMeta[],
  mocks: OperationMocksMap
): string {
  // noinspection DuplicatedCode
  const suffix = importsMode === "bare" ? "" : `.${importsMode}`;
  const testAppImport = `../helpers/test-app${suffix}`;
  const mockClientImport = `../helpers/mock-client${suffix}`;

  const sortedOps = [...operations].sort((a, b) => a.operationId.localeCompare(b.operationId));
  const op = sortedOps[0];
  if (!op) return "// No operations found\n";

  const mockData = mocks.get(op.operationId);
  const requestPayload = JSON.stringify(mockData?.request ?? {}, null, 4).replace(/\n/g, "\n    ");

  return `/**
 * Gateway Envelope Structure Tests
 *
 * Validates SUCCESS and ERROR envelope shapes.
 *
 * Auto-generated by wsdl-tsc --test-dir. Customize freely.
 */
import { describe, it, expect } from "vitest";
import { createTestApp } from "${testAppImport}";
import { createMockClient } from "${mockClientImport}";

describe("gateway — envelope structure", () => {
  it("success envelope has correct shape", async () => {
    const app = await createTestApp();
    try {
      const res = await app.inject({
        method: "${op.method.toUpperCase()}",
        url: "${op.path}",
        payload: ${requestPayload},
      });
      expect(res.statusCode).toBe(200);
      const body = res.json();
      expect(body).toHaveProperty("status", "SUCCESS");
      expect(body).toHaveProperty("message", null);
      expect(body).toHaveProperty("data");
      expect(body).toHaveProperty("error", null);
    } finally {
      await app.close();
    }
  });

  it("error envelope has correct shape", async () => {
    const app = await createTestApp(
      createMockClient({
        ${op.operationId}: async () => {
          throw new Error("test error");
        },
      })
    );
    try {
      const res = await app.inject({
        method: "${op.method.toUpperCase()}",
        url: "${op.path}",
        payload: ${requestPayload},
      });
      expect(res.statusCode).toBe(500);
      const body = res.json();
      expect(body).toHaveProperty("status", "ERROR");
      expect(body).toHaveProperty("message");
      expect(body).toHaveProperty("data", null);
      expect(body.error).toHaveProperty("code");
      expect(body.error).toHaveProperty("message");
    } finally {
      await app.close();
    }
  });
});
`;
}

/**
 * Emits gateway/validation.test.ts with invalid payload tests per route.
 */
// noinspection JSUnusedLocalSymbols
export function emitValidationTest(
  testDir: string,
  importsMode: "js" | "ts" | "bare",
  operations: ResolvedOperationMeta[]
): string {
  const suffix = importsMode === "bare" ? "" : `.${importsMode}`;
  const testAppImport = `../helpers/test-app${suffix}`;

  const sortedOps = [...operations].sort((a, b) => a.operationId.localeCompare(b.operationId));

  const testCases = sortedOps.map((op) => {
    return `  it("${op.method.toUpperCase()} ${op.path} rejects array body", async () => {
    const app = await createTestApp();
    try {
      const res = await app.inject({
        method: "${op.method.toUpperCase()}",
        url: "${op.path}",
        payload: [1, 2, 3],
      });
      expect(res.statusCode).toBe(400);
    } finally {
      await app.close();
    }
  });`;
  }).join("\n\n");

  return `/**
 * Gateway Validation Tests
 *
 * Tests that invalid payloads are rejected per route.
 *
 * Auto-generated by wsdl-tsc --test-dir. Customize freely.
 */
import { describe, it, expect } from "vitest";
import { createTestApp } from "${testAppImport}";

describe("gateway routes — validation", () => {
${testCases}
});
`;
}

/**
 * Emits runtime/classify-error.test.ts with direct classifyError() unit tests.
 */
export function emitClassifyErrorTest(
  testDir: string,
  gatewayDir: string,
  importsMode: "js" | "ts" | "bare"
): string {
  const runtimeDir = `${testDir}/runtime`;
  const runtimeImport = computeRelativeImport(runtimeDir, `${gatewayDir}/runtime`, importsMode);

  return `/**
 * classifyError() Unit Tests
 *
 * Direct unit tests of the classifyError() function from gateway runtime.
 *
 * Auto-generated by wsdl-tsc --test-dir. Customize freely.
 */
import { describe, it, expect } from "vitest";
import { classifyError } from "${runtimeImport}";

describe("classifyError", () => {
  it("returns 400 for validation errors", () => {
    const err = Object.assign(new Error("Validation failed"), {
      validation: [{ message: "body/field must be string" }],
    });
    const result = classifyError(err);
    expect(result.httpStatus).toBe(400);
    expect(result.code).toBe("VALIDATION_ERROR");
  });

  it("returns 502 for SOAP faults", () => {
    const err = Object.assign(new Error("SOAP fault"), {
      root: {
        Envelope: {
          Body: {
            Fault: {
              faultcode: "soap:Server",
              faultstring: "Service error",
            },
          },
        },
      },
    });
    const result = classifyError(err);
    expect(result.httpStatus).toBe(502);
    expect(result.code).toBe("SOAP_FAULT");
  });

  it("returns 503 for ECONNREFUSED", () => {
    const result = classifyError(new Error("connect ECONNREFUSED 127.0.0.1:80"));
    expect(result.httpStatus).toBe(503);
    expect(result.code).toBe("SERVICE_UNAVAILABLE");
  });

  it("returns 503 for ENOTFOUND", () => {
    const result = classifyError(new Error("getaddrinfo ENOTFOUND soap.example.com"));
    expect(result.httpStatus).toBe(503);
    expect(result.code).toBe("SERVICE_UNAVAILABLE");
  });

  it("returns 504 for ETIMEDOUT", () => {
    const result = classifyError(new Error("ETIMEDOUT"));
    expect(result.httpStatus).toBe(504);
    expect(result.code).toBe("GATEWAY_TIMEOUT");
  });

  it("returns 504 for timeout messages", () => {
    const result = classifyError(new Error("Request timeout after 30000ms"));
    expect(result.httpStatus).toBe(504);
    expect(result.code).toBe("GATEWAY_TIMEOUT");
  });

  it("returns 500 for unknown errors", () => {
    const result = classifyError(new Error("something unexpected"));
    expect(result.httpStatus).toBe(500);
    expect(result.code).toBe("INTERNAL_ERROR");
  });

  it("handles non-Error values", () => {
    const result = classifyError("string error");
    expect(result.httpStatus).toBe(500);
    expect(result.code).toBe("INTERNAL_ERROR");
    expect(result.message).toBe("string error");
  });
});
`;
}

/**
 * Emits runtime/envelope-builders.test.ts with buildSuccessEnvelope/buildErrorEnvelope tests.
 */
export function emitEnvelopeBuildersTest(
  testDir: string,
  gatewayDir: string,
  importsMode: "js" | "ts" | "bare"
): string {
  const runtimeDir = `${testDir}/runtime`;
  const runtimeImport = computeRelativeImport(runtimeDir, `${gatewayDir}/runtime`, importsMode);

  return `/**
 * Envelope Builder Unit Tests
 *
 * Tests buildSuccessEnvelope() and buildErrorEnvelope() from gateway runtime.
 *
 * Auto-generated by wsdl-tsc --test-dir. Customize freely.
 */
import { describe, it, expect } from "vitest";
import { buildSuccessEnvelope, buildErrorEnvelope } from "${runtimeImport}";

describe("buildSuccessEnvelope", () => {
  it("produces correct structure", () => {
    const envelope = buildSuccessEnvelope({ foo: "bar" });
    expect(envelope).toEqual({
      status: "SUCCESS",
      message: null,
      data: { foo: "bar" },
      error: null,
    });
  });

  it("accepts optional message", () => {
    const envelope = buildSuccessEnvelope({ foo: "bar" }, "All good");
    expect(envelope.message).toBe("All good");
  });
});

describe("buildErrorEnvelope", () => {
  it("produces correct structure", () => {
    const envelope = buildErrorEnvelope("SOME_ERROR", "Something failed");
    expect(envelope).toEqual({
      status: "ERROR",
      message: "Something failed",
      data: null,
      error: { code: "SOME_ERROR", message: "Something failed" },
    });
  });

  it("includes details when provided", () => {
    const envelope = buildErrorEnvelope("SOME_ERROR", "Failed", { reason: "timeout" });
    expect(envelope.error.details).toEqual({ reason: "timeout" });
  });
});
`;
}

/**
 * Emits runtime/unwrap.test.ts with unwrapArrayWrappers tests.
 * Returns null if no array wrappers exist in the catalog.
 */
export function emitUnwrapTest(
  testDir: string,
  gatewayDir: string,
  importsMode: "js" | "ts" | "bare",
  catalog: CatalogForMocks
): string | null {
  // Detect array wrappers using shared utility with full type definitions
  const types = catalog.types ?? [];
  const wrappers = detectArrayWrappers(types);
  if (Object.keys(wrappers).length === 0) return null;

  // Detect children-only types (in CHILDREN_TYPES but NOT in ARRAY_WRAPPERS)
  const childTypeMap = catalog.meta?.childType ?? {};
  const childrenOnly = detectChildrenTypes(childTypeMap, wrappers);

  const runtimeDir = `${testDir}/runtime`;
  const runtimeImport = computeRelativeImport(runtimeDir, `${gatewayDir}/runtime`, importsMode);

  const wrapperTests = Object.entries(wrappers).map(([wrapperType, innerKey]) => {
    return `  it("unwraps ${wrapperType} to flat array", () => {
    const wrapped = { ${innerKey}: [{ id: 1 }] };
    const result = unwrapArrayWrappers(wrapped, "${wrapperType}");
    expect(result).toEqual([{ id: 1 }]);
  });`;
  }).join("\n\n");

  // Generate tests for children-only types that have nested wrappers
  const childrenTests: string[] = [];
  for (const [typeName, children] of Object.entries(childrenOnly)) {
    // Find children whose types are array wrappers (these get recursively unwrapped)
    const wrappedChildren = Object.entries(children).filter(([, childType]) => childType in wrappers);
    if (wrappedChildren.length === 0) continue;

    const [childProp, childType] = wrappedChildren[0];
    const innerKey = wrappers[childType];
    childrenTests.push(`  it("recursively unwraps nested wrappers in ${typeName}", () => {
    const input = { ${childProp}: { ${innerKey}: [{ id: 1 }] } };
    const result = unwrapArrayWrappers(input, "${typeName}");
    expect(result).toEqual({ ${childProp}: [{ id: 1 }] });
  });`);
  }

  const childrenTestBlock = childrenTests.length > 0
    ? "\n" + childrenTests.join("\n\n") + "\n"
    : "";

  return `/**
 * unwrapArrayWrappers() Unit Tests
 *
 * Tests the ArrayOf* wrapper unwrapping from gateway runtime.
 *
 * Auto-generated by wsdl-tsc --test-dir. Customize freely.
 */
import { describe, it, expect } from "vitest";
import { unwrapArrayWrappers } from "${runtimeImport}";

describe("unwrapArrayWrappers", () => {
${wrapperTests}
${childrenTestBlock}
  it("returns empty array when inner key is missing", () => {
    const result = unwrapArrayWrappers({}, "${Object.keys(wrappers)[0]}");
    expect(result).toEqual([]);
  });

  it("returns null/undefined/primitives unchanged", () => {
    expect(unwrapArrayWrappers(null, "Anything")).toBeNull();
    expect(unwrapArrayWrappers(undefined, "Anything")).toBeUndefined();
    expect(unwrapArrayWrappers("hello", "Anything")).toBe("hello");
  });
});
`;
}

